## 이것부터 시작
- PR 템플릿 세팅
- `/point` 패키지 내에 PointService 기본 기능 작성
- `/database` 패키지의 구현체를 수정하지 말고, 이를 활용해 기능을 구현
- 각 기능에 대한 단위 테스트 작성
  - 포인트 조회
  - 포인트 충전과 사용 내역 조회
  - 포인트 충전
  - 포인트 사용

## 기본과제
- 포인트 충전, 포인트 사용에 대한 정책 추가
  - 잔고 부족
  - 최대 잔고
- 동시에 여러 요청이 들어오면, 순서대로(또는 한번에 하나의 요청씩) 제어될 수 있도록 리펙토링 
- 동시성 제어에 대한 통합 테스트 작성

## 심화과제
- 동시성 제어 방식에 대한 분석 및 보고서 작성
  - README.md

## ℹ️ 과제 필수 사항

- Nest.js 의 경우 Typescript , Spring 의 경우 Kotlin / Java 중 하나로 작성합니다.
    - 프로젝트에 첨부된 설정 파일은 수정하지 않도록 합니다.
- 테스트 케이스의 작성 및 작성 이유를 주석으로 작성하도록 합니다.
- 프로젝트 내의 주석을 참고하여 필요한 기능을 작성해주세요.
- 분산 환경은 고려하지 않습니다.

## ❓ [과제] `point` 패키지의 TODO 와 테스트코드를 작성해주세요.

**요구 사항**

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- *GET `/point/{id}` : 포인트를 조회한다.*
- *GET `/point/{id}/histories` : 포인트 내역을 조회한다.*
- *잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.*
- *동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.*

---

## 정책
- 포인트는 항상 0원 이상 1_000_000원 이하로만 구성이 된다.
- 포인트 충전은 최소 1_000원 이상, 100_000원 이하이다.
- 포인트 사용은 최소 1_000원 이상, 500_000원 이하이다.

## 1. PointService 테스트 사나리오

- interface 이기 때문에 입력과 출력에 초점을 맞춤

### 포인트 충전
- 성공
  - 포인트 충전에 성공한다.
  - 유저가 포인트 충전 후 포인트 히스토리에 저장이 성공한다.
  - 유저가 포인트 충전 후 포인트 합계 조회가 1,000,000 초과면 1,000,000로 반환 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 충전하면 실패한다.
  - 유저가 1,000 미만의 포인트를 충전하면 실패한다.
  - 유저가 100,000 초과의 포인트를 충전하면 실패한다.

### 포인트 사용
- 성공
  - 포인트 사용에 성공한다.
  - 유저가 포인트 사용 후 포인트 히스토리에 저장이 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 사용하면 실패한다.
  - 유저가 1,000 미만의 포인트를 사용하면 실패한다.
  - 유저가 500,000 초과의 포인트를 사용하면 실패한다.
  - 유저가 현재 가지고 있는 포인트보다 많은 포인트를 사용하면 실패한다.

### 포인트 조회
- 성공
  - 포인트 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 조회하면 실패한다.

### 포인트 충전과 사용 내역 조회
- 성공
  - 포인트 충전과 포인트 사용내역 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트 충전과 포인트 사용내역을 조회하면 실패한다.

## 2. PointServiceImpl 단위 테스트 사나리오

- 비즈니스 로직(실제 구현체, PointServiceImpl) 단위 테스트

### 포인트 충전
- 성공
  - 포인트 충전에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 충전하면 실패한다.
  - 유저가 1,000 미만의 포인트를 충전하면 실패한다.
  - 유저가 100,000 초과의 포인트를 충전하면 실패한다.

### 포인트 사용
- 성공
  - 포인트 사용에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 사용하면 실패한다.
  - 유저가 1,000 미만의 포인트를 사용하면 실패한다.
  - 유저가 500,000 초과의 포인트를 충전하면 실패한다.
  - 유저가 현재 가지고 있는 포인트보다 많은 포인트를 사용하면 실패한다.

### 포인트 조회
- 성공
  - 포인트 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 조회하면 실패한다.

### 포인트 충전과 사용 내역 조회
- 성공
  - 포인트 충전과 포인트 사용내역 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트 충전과 포인트 사용내역을 조회하면 실패한다.

## 3. PointService 통합 테스트 시나리오

- PointService 통합테스트

### 포인트 충전
- 성공
  - 포인트 충전에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 충전하면 실패한다.
  - 유저가 1,000 미만의 포인트를 충전하면 실패한다.
  - 유저가 100,000 초과의 포인트를 충전하면 실패한다.

### 포인트 사용
- 성공
  - 포인트 사용에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 사용하면 실패한다.
  - 유저가 1,000 미만의 포인트를 사용하면 실패한다.
  - 유저가 500,000 초과의 포인트를 충전하면 실패한다.
  - 유저가 현재 가지고 있는 포인트보다 많은 포인트를 사용하면 실패한다.

### 포인트 조회
- 성공
  - 포인트 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트를 조회하면 실패한다.

### 포인트 충전과 사용 내역 조회
- 성공
  - 포인트 충전과 포인트 사용내역 조회에 성공한다.
- 실패
  - 존재하지 않는 유저가 포인트 충전과 포인트 사용내역을 조회하면 실패한다.

## 4. 동시성 문제가 발생할 가능성이 있는 시나리오

- 동시성 문제는 다중 요청이 동일한 리소스를 접근할 때 발생
- 동시성 문제 발생 가능성
  - 같은 사용자가 동시에 포인트 충전 요청을 보낼 때 데이터 일관성 문제
  - 같은 사용자가 동시에 포인트 사용 요청을 보낼 때 초과 사용 방지 실패
  - 충전과 요청이 동시에 들어올 때 처리 순서로 인해 잘못된 결과

### 목표
- 동시성 문제 해결: 동시 요청 시, 데이터 정합성을 유지하도록 시스템을 리펙토링
- 테스트 강화

### 1. 포인트 충전 동시 요청
- 여러 스레드가 `동시에 같은 사용자`에게 포인트 충전 요청
- 기대결과: `최종 잔고`가 `모든 충전 요청의 합산 결과`와 `동일`

### 2. 포인트 사용 동시 요청
- 여러 스레드가 `동시에 같은 사용자`에게 포인트 사용 요청
- 기대결과: 모`든 요청이 처리된 후 잔고가 정확`하며, `초과 사용은 실패`

### 3. 충전 및 사용 동시 요청
- 여러 스레드가 `동시에 같은 사용자에게 충전 요청과 사용 요청`
- 기대결과: `사용 요청이 잔고보다 크면 실패`하며, `최종결과는 순차 처리 결과와 동일`

### 테스트 구현 계획
- JUnit5, Mockito, ExecutorService(다중 멀티 스레드)
- CountDownLatch: 모든 스레드가 실행될 때까지 대기
- 테스트 코드 작성
  - 초기 상태 설정: 사용자 생성 및 초기 포인트 설정
  - 동시 요청 생서: 다중 스레드로 충전/사용 요청 실행
  - 결과 검증: 요청이 모두 처리된 후 데이터 일관성 확인

### 테스트 코드 실행 후 결과 확인
- 모든 테스트가 통화: 데이터 정합성 유지, 동시성 제어가 올바르게 작동
